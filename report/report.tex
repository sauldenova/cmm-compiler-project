\documentclass[11pt]{article}

\usepackage[spanish,mexico]{babel}
\usepackage{epsfig}
\usepackage{float}
\usepackage[margin=2.5cm]{geometry}
\usepackage[utf8]{inputenc}
\usepackage{hyperref}

\begin{document}

\title{Metodología empleada y manual de operación}
\author{
    \Large Diseño de compiladores
    \\
    \textit{Dr. Edgar E. Vallejo}
    \\
    \\
    Saúl de Nova Caballero (A01165957)
    \\
    Diego Galíndez Barreda (A01370815)
}
\maketitle

\section{Metodología empleada}

A continuación viene un resumen de los cambios que se hicieron a la especificación para poder cumplir todos los requerimientos.

\subsection{Expresiones regulares}

Para las expresiones regulares, se convirtieron todos los operadores, tipos y palabras claves del lenguaje en tokens. También 
se verificaron constantes de strings, enteros en hexadecimal y enteros, flotantes en notación científica y sin la notación. 
Se consideraron todas las cadenas que no tengan saltos de línea como válidas. Se verificó para los identificadores que fueran 
a lo más de 31 caracteres. En el caso de que un caracter no sea ' ', \textbackslash n, \textbackslash r ó \textbackslash t.
\\\\
Para acomodar comentarios, se utilizó la instrucción \textbf{BEGIN} para determinar los estados de flex. Se creó el estado 
\textbf{C\_COMMENT} para determinar cuando te encuentras dentro de un comentario.

\subsection{Modificaciones a la gramática}

Para manejar los bloques de código en las instrucciones adecuadas, $if$, $for$, $while$, $block$, se insertaron expresiones $scopeStart$ y $scopeEnd$ para manejar la profundidad de las tablas de símbolos.

Para poder tener las expresiones con $^+$ y $^*$ se descompusieron las expresiones de la siguiente manera:
\\\\
$Expr\,::=\,Term^+$
\\
$Expr\,::=\,Term\,|\,Expr\,Term$
\\\\
se cambió a:
\\\\
$Expr\,::=\,Term^*$
\\
$Expr\,::=\,\epsilon\,|\,Expr\,Term$
\\\\
Con el propósito de generar el código intermedio correcto indexando, arreglos y \textit{strings},  se cambió  valorL y expr. El valor original era:
\\\\
$Expr\,::=\,ValorL\,|\,ValorL\,=\,Expr$
\\
$ValorL\,::=\,identificador\,|\,Expr\,[\,Expr\,]$
\\\\
se cambió a:
\\\\
$Expr\,::=\,ValorL\,|\,ValorL\,=\,Expr\,|\,ValorL\,[\,Expr\,]\,|\,ValorL\,[\,Expr\,]\,=\,Expr$
\\
$ValorL\,::=\,identificador$
\\\\
Para poder hacer los reales y los formales, se separó la gramática en 3 para poder acomodar comas, vacíos y final sin comas.
\\\\
$Reals\,::=\,Expr^+\,,\,|\,\epsilon$
\\\\
se cambió a:
\\\\
$Reals\,::=\,\epsilon\,|\,RealsDefEnd$
\\
$RealsDefEnd\,::=\,expr\,|\,RealsDef\,expr$
\\
$RealsDef\,::=\,expr\,,|\,RealsDef\,expr\,,$
\\\\
Para finalizar, en las funciones se nos presentó un problema. Para poder asegurarnos que los tipos de los \textit{returns} fueran correctos tuvimos que cambiar la gramática de esto:
\\\\
$DeclFuncion\,::=\,Tipo\,identificador\,(Formales)\,BloqueInstr$
\\
$|\,void \,identificador\,(Formales)\,BloqueInstr$
\\\\
a:
\\\\
$DeclFuncion\,::=\,TipoFuncion\,(Formales)\,BloqueInstr$
\\
$TipoFuncion\,::=\,tipo\,identificador$
$|\,void\,identificador$
\\\\
Este cambio puede parecer minúsculo, sin embargo, nos permite que la tabla de símbolos guarde el identificador de la función para ser usado en la función de abajo.
\\\\
Para manejar los \textit{fors} en vez de utilizar la técnica de \textit{backpatching} se cambió la gramática y se insertaron expresiones vacías, cuyo único propósito es generar código. Por lo que las expresiones:
\\\\
$InstrIf\,::=\,if\,(\,Expr\,)\,Instr\,<\,else\,Instr\,>$
\\
$InstrWhile\,::=\,while\,(\,Expr\,)\,Instr$
\\
$InstrFor\,::=\,for\,(\,<\,expr\,>\,;\,Expr\,;\,<\,expr\,>\,)\,Instr$
\\\\
se cambiaron a:
\\\\
$InstrIf\,::=\,if\,(\,\mathbf{InstrIfCond}\,)\,Instr\,\mathbf{InstrIfEnd}$
\\
$InstrIf\,::=\,if\,(\,\mathbf{InstrIfCond}\,)\,Instr\,\mathbf{InstrIfElse}\,else\,Instr\,\mathbf{InstrIfElseEnd}$
\\
$InstrWhile\,::=\,\mathbf{InstrWhileStart}\,while\,(\,\mathbf{InstrWhileCond}\,)\,Instr\,\mathbf{InstrWhileEnd}$
\\
$InstrFor\,::=\,for\,(\,<\,expr\,>\,\mathbf{InstrForStart}\,;\,\mathbf{InstrForCond}\,;\,<\,expr\,>\,)$
\\
$>\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\mathbf{InstrForLabel}\,Instr\,\mathbf{InstrForEnd}$
\\\\

\subsection{Tabla de símbolos}

Para poder manejar adecuadamente los scopes del programa fue necesario utilizar una tabla recursiva de símbolos. Se muestra el 
concepto en la figura \ref{fig:symtabrec}.

\begin{figure}[H]
    \centering
    \epsfig{figure=images/symbols.png,width=3in}
    \caption{Tabla recursiva de símbolos}
    \label{fig:symtabrec}
\end{figure}

En el momento en que se cambia el scope (\textbf{instrIf}, \textbf{instrWhile}, \textbf{instrFor}, \textbf{declFunction}), se 
crea una nueva tabla de símbolos. Todas las tablas tienen una tabla padre, por lo que se puede regresar al scope padre.
\\\\
Las tablas utilizan los hashes de los símbolos. Si hay colisiones utiliza una lista para agregar varios símbolos al mismo hash.
\\\\
Los símbolos incluyen un nombre, un tipo y un contador de las veces que se accesa la variable. Tenemos una función lookup que 
busca recursivamente los símbolos, por lo tanto tenemos overshadowing.

\subsection{Manejo de tipos}

Para manejar los diferentes tipos que se pueden programar en cmm: $int$, $bool$, $double$, $string[]$, $int[]$, $bool[]$, $double[]$, se definieron constantes enteras para identificar los tipos.

\subsection{Generación de código intermedio}

Al momento de generar el código intermedio se consideraron muchas alternativas. En nuestro caso se utilizó el lenguaje intermedio de LLVM (\url{http://llvm.org/releases/3.6.2/docs/LangRef.html}). LLVM es una colección de herramientas que utilizan muchas empresas y lenguajes para compilar sus propios programas.

\subsubsection{Runtime}

Es necesario declarar un archivo que declare las implementaciones de las funciones incluidas en el lenguaje. Este archivo implementa las funciones \textbf{printInt}, \textbf{printDouble}, \textbf{printString} que utiliza internamente la función \textbf{print}. El archivo está escrito en el lenguaje intermedio.

\subsection{Arquitectura}

\begin{figure}[H]
    \centering
    \epsfig{figure=images/architecture.png,width=6in}
    \caption{Arquitectura del compilador}
    \label{fig:arch}
\end{figure}

Esta arquitectura corre en serie. Es decir el programa de hasta la izquierda recibe el archivo de input, corre el \textit{front end} y genera el archivo \textbf{program.ll}. Las herramientas realizan lo siguiente:

\begin{enumerate}
	\item \textbf{out/cmmFront}: Corre el \textit{front end} que incluye el parser, el scanner y genera el código intermedio.
	\item \textbf{llvm-as}: Convierte el código intermedio a bitcode.
	\item \textbf{llvm-link}: \textit{Linkea} los programas en bitcode.
	\item \textbf{opt}: Optimiza el programa \textit{linkeado} por \textbf{llvm-link}.
	\item \textbf{llc}: Corre el \textit{back end} y genera un archivo de objeto \textbf{.o}
	\item \textbf{clang}: Corre el linker de otro compilador para \textit{linkear} el \textbf{.o} con las \textit{librerías} del sistema y generar un ejecutable.
\end{enumerate}

\subsection{Overshadowing de variables}

Para manejar overshadowing de variables, generamos nombres diferentes en el archivo intermedio. Internamente en el \textit{front end} utilizamos una estructura \textbf{t\_symbol} que tiene dos cambios, \textbf{internalName} y \textbf{name}. \textbf{internalName} se asigna de acuerdo a las variables con el mismo nombre definidas en el bloque padre.

\pagebreak

\section{Manual de usuario}

\subsection{Compilación}

Para compilar el programa tenemos un Makefile. Este archivo tiene las siguientes opciones:e
\\\\
El comando \textbf{make} o \textbf{make help} muestran la documentación correspondiente de las opciones de make.
\\\\
Una vez modificadas las variables, para compilar el programa utilizamos el comando: \textbf{make build}.
\\\\
Para correr las pruebas del sistema utiliza el comando: \textbf{make test}.
\\\\
Para limpiar los ejecutables utiliza el comando: \textbf{make clean}.

\subsection{Corrimiento programa}

Para compilar un programa utilizamos el comando \textbf{cmm}. El compilador tiene la siguiente ayuda:
 
\begin{verbatim}
usage: cmm [-h] [-o output] source

Compiler for the cmm language. Currently uses a LLVM backend.

positional arguments:
  source      The source file to be compiled

optional arguments:
  -h, --help  show this help message and exit
  -o output   The output destination file. By default this value is a.out
\end{verbatim}

\end{document}
