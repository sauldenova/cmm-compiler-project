#!/usr/bin/python

from __future__ import print_function
from distutils.spawn import find_executable

import argparse
import platform
import subprocess
import sys
import os.path

def warning(*objs):
    print("Warning: ", *objs, file=sys.stderr)

def error(*objs):
    print("Error: ", *objs, file=sys.stderr)
    sys.exit(1)

def parse_arguments():
    parser = argparse.ArgumentParser(description='Compiler for the cmm language. Currently uses a LLVM backend.')

    parser.add_argument('-o', dest='output', type=str, default='result',
                        help='the output destination file. By default this value is result.{target_extension}')

    parser.add_argument('--optimize', dest='optimized', action='store_true', default=False,
                        help='optimize the generated intermediate code')

    parser.add_argument('--target', dest='target', type=str, default='executable',
                        choices=['assembly', 'executable', 'intermediate'],
                        help='tells the compiler which is the target it should generate')

    parser.add_argument('--arch', dest='arch', type=str, default='current',
                        choices=['mips', 'current'],
                        help='tells the compiler the target architecure you\
                        want for your output. If the target doesn\'t generate\
                        code, this flag is ignored')

    parser.add_argument('source', type=argparse.FileType('r'), nargs=1,
                        help='the source file to be compiled')

    return parser.parse_args()

def find_tools():
    clang = find_executable('clang')
    if not clang:
        clang = find_executable('gcc')
        if not clang:
            error('Neither gcc not clang where found, please install any of them')

    rm = find_executable('rm')
    if not rm:
        error('Executable rm not found, please make sure you\'re in a *nix system')

    mv = find_executable('mv')

    llvm_as = find_executable('llvm-as')
    if not llvm_as:
        if platform.system() == 'Linux':
            llvm_as = os.path.abspath('./bin/linux/llvm-as')
        else:
            llvm_as = os.path.abspath('./bin/osx/llvm-as')

    llvm_link = find_executable('llvm-link')
    if not llvm_link:
        if platform.system() == 'Linux':
            llvm_link = os.path.abspath('./bin/linux/llvm-link')
        else:
            llvm_link = os.path.abspath('./bin/osx/llvm-link')

    llvm_opt = find_executable('opt')
    if not llvm_opt:
        if platform.system() == 'Linux':
            llvm_opt = os.path.abspath('./bin/linux/opt')
        else:
            llvm_opt = os.path.abspath('./bin/osx/opt')

    llvm_llc = find_executable('llc')
    if not llvm_llc:
        if platform.system() == 'Linux':
            llvm_llc = os.path.abspath('./bin/linux/llc')
        else:
            llvm_llc = os.path.abspath('./bin/osx/llc')

    llvm_dis = find_executable('llvm-dis')
    if not llvm_dis:
        if platform.system() == 'Linux':
            llvm_dis = os.path.abspath('./bin/linux/llvm-dis')
        else:
            llvm_dis = os.path.abspath('./bin/osx/llvm-dis')

    cmm_front = os.path.abspath('./out/cmmFront')
    if not os.path.isfile(cmm_front):
        error('CMM front is not built, please build the project before continuing')

    return (clang, rm, mv, llvm_as, llvm_link, llvm_opt, llvm_llc, llvm_dis, cmm_front)

def main():
    args = parse_arguments()

    clang, rm, mv, llvm_as, llvm_link, llvm_opt, llvm_llc, llvm_dis, cmm_front = find_tools()

    extension = ''
    if args.target == 'assembly':
        extension = '.s'
    elif args.target == 'intermediate':
        extension = '.ll'

    source_file = args.source[0]
    output_file = args.output

    source_file.close()

    output_file_name = os.path.splitext(output_file)[0] + extension

    target_triple = ''
    if args.arch == 'mips':
        target_triple = 'mips-mipstechnologies'

    if os.path.splitext(source_file.name)[1] != '.ll':
        return_code = subprocess.call([cmm_front, source_file.name, target_triple])
        if return_code != 0:
            exit(1)

    return_code = subprocess.call([llvm_as, 'program.ll'])
    if return_code != 0:
        error("Fatal error generated code was incorrect")

    subprocess.call([llvm_as, 'runtime.ll'])

    llvm_link_flags = '-o=main.bc'
    subprocess.call([llvm_link, llvm_link_flags, 'program.bc', 'runtime.bc'])

    intermediate_bitcode = 'main.bc'
    if args.optimized:
        intermediate_bitcode = 'main_opt.bc'

        llvm_opt_flags = '-std-link-opts'

        llvm_opt_args = [llvm_opt]
        llvm_opt_args.extend(llvm_opt_flags.split(' '))
        llvm_opt_args.append('-o=main_opt.bc')
        llvm_opt_args.append('main.bc')

        subprocess.call(llvm_opt_args)

    if args.target == 'intermediate':
        subprocess.call([llvm_dis, intermediate_bitcode])
        subprocess.call([mv, intermediate_bitcode.replace('.bc', '.ll'), output_file_name])
    else:
        llvm_llc_flags = '-filetype=obj'
        if args.target == 'assembly':
            llvm_llc_flags = '-filetype=asm'

        llvm_llc_flags += ' -O0'
        if args.arch == 'mips':
            llvm_llc_flags += ' -relocation-model=static'

        llvm_llc_args = [llvm_llc]
        llvm_llc_args.extend(llvm_llc_flags.split(' '))
        llvm_llc_args.append(intermediate_bitcode)

        subprocess.call(llvm_llc_args)

        if args.target == 'assembly':
            subprocess.call([mv, intermediate_bitcode.replace('.bc', '.s'), output_file_name])

        if args.target == 'executable':
            clang_flags = '-o' + output_file_name
            subprocess.call([clang, clang_flags, '-w', intermediate_bitcode.replace('.bc', '.o')])

    with open('/dev/null', 'w') as dev_null:
        subprocess.call([rm,
                         'program.ll' if os.path.splitext(source_file.name)[1] != '.ll' else '',
                         'program.bc',
                         'runtime.bc',
                         'main.bc',
                         intermediate_bitcode,
                         intermediate_bitcode.replace('.bc', '.o')],
                        stderr=dev_null)

    return

# If we are running in a console environment
if __name__ == '__main__':
    main()

