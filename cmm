#!/usr/bin/python

from __future__ import print_function
from distutils.spawn import find_executable

import argparse
import subprocess
import sys
import os.path

def warning(*objs):
    print("Warning: ", *objs, file=sys.stderr)

def error(*objs):
    print("Error: ", *objs, file=sys.stderr)
    sys.exit(1)

def parse_arguments():
    parser = argparse.ArgumentParser(description='Compiler for the cmm language. Currently uses a LLVM backend.')

    parser.add_argument('-o', dest='output', type=argparse.FileType('w'),
                        default='a.out', metavar='output',
                        help='The output destination file. By default this value is a.out')

    parser.add_argument('source', type=argparse.FileType('r'), nargs=1,
                        help='The source file to be compiled')

    return parser.parse_args()

def find_tools():
    clang = find_executable('clang')
    if not clang:
        clang = find_executable('gcc')
        if not clang:
            error('Neither gcc not clang where found, please install any of them')

    rm = find_executable('rm')
    if not rm:
        error('Executable rm not found, please make sure you\'re in a *nix system')

    llvm_as = find_executable('llvm-as')
    if not llvm_as:
        if not os.path.isfile('/usr/local/Cellar/llvm/3.6.2/bin/llvm-as'):
            error('LLVM suite not found, please install')
        llvm_as = '/usr/local/Cellar/llvm/3.6.2/bin/llvm-as'

    llvm_link = find_executable('llvm-link')
    if not llvm_link:
        llvm_link = '/usr/local/Cellar/llvm/3.6.2/bin/llvm-link'

    llvm_opt = find_executable('opt')
    if not llvm_opt:
        llvm_opt = '/usr/local/Cellar/llvm/3.6.2/bin/opt'

    llvm_llc = find_executable('llc')
    if not llvm_llc:
        llvm_llc = '/usr/local/Cellar/llvm/3.6.2/bin/llc'

    cmm_front = os.path.abspath('./out/cmmFront')
    if not os.path.isfile(cmm_front):
        error('CMM front is not built, please build the project before continuing')

    return (clang, rm, llvm_as, llvm_link, llvm_opt, llvm_llc, cmm_front)

def main():
    args = parse_arguments()

    clang, rm, llvm_as, llvm_link, llvm_opt, llvm_llc, cmm_front = find_tools()

    source_file = args.source[0]
    output_file = args.output

    source_file.close()
    output_file.close()

    clang_flags = '-o' + output_file.name
    llvm_link_flags = '-o=main.bc'
    llvm_opt_flags = '-std-link-opts'
    llvm_llc_flags = '-filetype=obj'

    return_code = subprocess.call([cmm_front, source_file.name])
    if return_code != 0:
        exit(1)

    return_code = subprocess.call([llvm_as, 'program.ll'])
    if return_code != 0:
        error("Fatal error")

    subprocess.call([llvm_as, 'runtime.ll'])
    subprocess.call([llvm_link, llvm_link_flags, 'program.bc', 'runtime.bc'])

    with open('main_opt.bc', 'w') as main_opt:
        subprocess.call([llvm_opt, llvm_opt_flags, 'main.bc'], stdout=main_opt)

    subprocess.call([llvm_llc, llvm_llc_flags, 'main_opt.bc'])

    subprocess.call([clang, clang_flags, '-w', 'main_opt.o'])
    subprocess.call([rm, 'program.ll', 'program.bc', 'runtime.bc', 'main.bc', 'main_opt.bc', 'main_opt.o'])

    return

# If we are running in a console environment
if __name__ == '__main__':
    main()

